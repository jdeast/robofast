import importlib
import yaml

from scipy.interpolate import Rbf
from astropy.coordinates import SkyCoord, AltAz, ICRS, EarthLocation
from astropy.time import Time
import astropy.units as u

class TelescopeBase:

    def __init__(self, config_file):
        # universal properties go here
        self.header = {}
        pass

    def initialize(self, tracking=True, derotate=True, pointing_model_file='config/pointing_model.yaml'):

        self.pointing_model = self.compute_pointing_model(pointing_model_file)
        self.header["P_MODEL"] = (pointing_model_file,'Pointing model file')

        pass

    def slew(self, ra_icrs, dec_icrs, epoch="J2000"):
        # convert to alt/az
        altaz = icrs_to_altaz(ra_icrs, dec_icrs)

        # feed it through the pointing model
        telescope_altaz = self.pointing_model(altaz)

        # convert to ra/dec
        telescope_icrs = altaz_to_icrs(telescope_altaz)

        self.slew(icrs)

        # update the header with new information
        self.header["ALT"] = (altaz[0], "Commanded altitude [deg]")
        self.header["AZM"] = (altaz[1], "Commanded azimuth [deg]")
        self.header["ALT_TARG"] = (altaz[0], "Target altitude [deg]")
        self.header["AZM_TARG"] = (altaz[1], "Target azimuth [deg]")
        self.header["ALT_TEL"] = (telescope_altaz[0], "Telescope altitude without pointing model correction [deg]")
        self.header["AZM_TEL"] = (telescope_altaz[1], "Telescope azimuth without pointing model correction [deg]")

        self.header["RA_ICRS"] = (ra_icrs, "RA (ICRS) [deg]")
        self.header["DE_ICRS"] = (dec_icrs, "DEC (ICRS) [deg]")
        self.header["RA_TARG"] = (ra_icrs, "RA of the Target [deg]")
        self.header["DE_TARG"] = (dec_icrs, "Dec of the Target [deg]")
        self.header["RA_TEL"] = (telescope_icrs[0], "RA without pointing model correction [deg]")
        self.header["DE_TEL"] = (telescope_icrs[1], "Dec without pointing model correction [deg]")


    def icrs_to_altaz(ra_icrs, dec_icrs):
        if not isinstance(obstime, Time):
            obstime = Time(obstime)

        icrs = SkyCoord(ra=ra_icrs * u.deg, dec=dec_icrs * u.deg, frame="icrs")
        altaz = icrs.transform_to(AltAz(obstime=obstime, location=location))

    def altaz_to_icrs(alt, az, obstime, location):
        """
        Convert AltAz coordinates to ICRS (RA, Dec).

        Parameters
        ----------
        alt : float or Quantity
            Altitude in degrees (or astropy Quantity with angle units).
        az : float or Quantity
            Azimuth in degrees (or astropy Quantity with angle units).
        obstime : str or astropy.time.Time
            Observation time (e.g., '2025-09-04 12:00:00').
        location : astropy.coordinates.EarthLocation
            Observer's location on Earth.

        Returns
        -------
        icrs_coord : astropy.coordinates.SkyCoord
            Sky coordinate in ICRS frame (RA, Dec).
        """
        if not isinstance(obstime, Time):
            obstime = Time(obstime)

        altaz = SkyCoord(
            alt=alt * u.deg,
            az=az * u.deg,
            frame=AltAz(obstime=obstime, location=location)
        )

        return altaz.icrs

    def compute_pointing_model(self, alt_actual, az_actual, alt_telescope, az_telescope, function='thin_plate'):
        """
        This computes the pointing model correction function given calibration points (generated by build_pointing_model)
        """

        x = np.cos(alt_actual) * np.cos(az_actual)
        y = np.cos(alt_actual) * np.sin(az_actual)
        z = np.sin(alt_actual)

        rbf_alt = Rbf(x, y, z, alt_telescope, function=function)
        rbf_az  = Rbf(z, y, z, az_telescope, function=function)

        def f(alt, az):
            """Map an actual alt/az to telescope alt/az."""

            x = np.cos(alt) * np.cos(az)
            y = np.cos(alt) * np.sin(az)
            z = np.sin(alt)

            return float(rbf_alt(x,y,z)), float(rbf_az(x,y,z))

        return f

    def build_pointing_model(self, center_brightest=False):
        """
        This builds a pointing model using a pointing model software

        If center_brightest is True, it slews to random bright stars, centers them, and uses their coordinates to compute the actual and observed coordinates. Otherwise, it will slew to a grid of RA/dec, platesolve, and use the center coordinates.
        """

        self.pointing_model = self.compute_pointing_model()


def load_telescope(config_file):
    with open(config_file) as f:
        config = yaml.safe_load(f)

    pkg_name = __package__
    hal_module_name = config["hal_module"]
    hal_class_name = config["hal_class"]
    full_module_name = f"{pkg_name}.hal.{hal_module_name}"

    # import the hardware abstraction layer
    mod = importlib.import_module(full_module_name)
    hal_class = getattr(mod, hal_class_name)

    class Telescope(TelescopeBase, hal_class):
        def __init__(self):
            TelescopeBase.__init__(self, config_file)
            hal_class.__init__(self,config_file)

    return Telescope()

